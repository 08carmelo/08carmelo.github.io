<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[国内外顶尖公司有哪些Android团队博客]]></title>
      <url>%2F2017%2F04%2F09%2Ftechblogs%2F</url>
      <content type="text"><![CDATA[下面是我收集的一些团队博客和个人博客，数量不在多在于精！大家可以留言补充，不定时更新。 国内互联网公司百度医生技术团队 微信开发团队QQ音乐团队QQ空间 手机淘宝团队天猫团队聚划算团队 魅族Flyme团队美团点评 国外公司google开发者中文官网facebook三星 国内大牛郭霖鸿洋谷哥的小弟老罗腾讯胡凯邓凡平技术小黑屋任玉刚小钢赵凯强非著名程序员 网站社区AndroidCat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[6.0以下国产手机权限处理]]></title>
      <url>%2F2017%2F04%2F09%2Fandroid_6.0_permission%2F</url>
      <content type="text"><![CDATA[前言Android是在6.0加入的权限机制，但是不少国产手机比如华为小米等，在6.0之前的设备已经在设置里面有权限开关。调皮的某个用户会关掉这个权限，然后去拍照什么的，直接崩掉了。之前大牛郭霖在csdn做了一期权限机制的教学直播，结束后我问了他这个问题，他的回答是简单try catch即可无需深究。那我想结合实际项目研究下这个问题。 Android权限机制简介Android是在6.0之前只需要在menifest注册，用户安装app会有一个权限列表，类似一份协议表示用户对此已经知晓。但是实际中哪个用户会认真去看呢？导致很多app滥用权限给用户造成风险，于是在6.0后Android推出9组危险权限，要求开发者不仅要在menifest注册还要动态申请权限，比如调用拍照会弹出权限提示，只有用户自己点了确定才能继续拍照。 测试了解了Android6.0权限机制后，我们用系统的权限API对国产手机测试一下。 测试设备：华为，系统版本4.4测试内容：拍照，通话，录音测试API： ContextCompat.checkSelfPermission：检查是否有某个权限 requestPermission：主动申请某个权限，看看回调结果测试代码：1234567891011121314151617181920String[] permissions = new String[]&#123;Manifest.permission.CALL_PHONE,Manifest.permission.CAMERA,Manifest.permission.RECORD_AUDIO&#125;; for(int i=0;i&lt;permissions.length;i++)&#123; String permission = permissions[i]; int check = ContextCompat.checkSelfPermission(MyActivity.this, permission); if(check== PackageManager.PERMISSION_GRANTED)&#123; Log.d("dml","权限通过"); &#125;else&#123; Log.d("dml","无权限"); &#125; requestPermission(permissions, new OnPermissionCallback() &#123; @Override public void onGranted() &#123; Log.d("dml","权限申请成功"); &#125; @Override public void onDenied(List&lt;String&gt; deniedPermissions) &#123; Log.d("dml","权限被拒绝"); &#125; &#125;); &#125; 先进入设置关闭这个app的电话，照相和录音权限 运行app，发现并没有弹出让用户开关权限的Dialiog，并且检查权限返回权限通过。看看日志： D/dml: android.permission.CALL_PHONE权限通过D/dml: android.permission.CALL_PHONE权限申请成功D/dml: android.permission.CAMERA权限通过D/dml: android.permission.CAMERA权限申请成功D/dml: android.permission.RECORD_AUDIO权限通过D/dml: android.permission.RECORD_AUDIO权限申请成功 结论检查权限和申请权限的api在华为4.4手机 完全失效，看下源码也不难得到印证： 当运行设备在23以下也就是6.0以下的设备时，权限申请其实是通过PackageManager.checkPermission()来进行，看下这个方法： 是个抽象方法，不过注释看出：只是判断你的apk也就是你的Manifest.xml有没有注册这个权限，有那么就返回true。 实际开发的问题 如果不去做检测，直接调用会如何呢？ 经过测试以华为Android4.4的手机为例，关闭上述三项权限进行操作，发现系统都弹出了没有权限的Toast，不一样的是：打电话：不能进入拨号界面，也没有闪退，没有异常输出打开摄像头：直接闪退，有异常输出录音：没有闪退，没有异常，录音开启了但是没有数据（如果我们直接用了这些空数据，极大可能崩溃） 厂商ROM只是给出了无权限提示，但我们要做的就是保证app不能崩溃！ 解决方案 在代码中我们针对Android6.0的权限检测（ContextCompat.checkSelfPermission和requestPermission）按照正常的写，保证在Android6.0以上的设备正常运行。 然后在具体的操作比如拨号，拍照或者录音，加一层tyr catch，能捕获到异常最好，不能捕获到的话继续第三步。 对具体机型我们加入if判断，对操作数据做合法性判断，比如录音生成的数据，下面以华为为例： 还是上面的代码，我们对三种操作都加上try catch：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MyActivity extends BaseActivity &#123; private Button btn1,btn2,btn3; private Camera camera; private AudioRecord mRecorder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity); btn1 = (Button) findViewById(R.id.button); btn2 = (Button) findViewById(R.id.button2); btn3 = (Button) findViewById(R.id.button3); btn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try&#123; call(); &#125;catch (Exception e)&#123; Log.e("dml","exception = " + e.getMessage()); &#125; &#125; &#125;); btn2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try&#123; openCamera(); &#125;catch (Exception e)&#123; Log.e("dml","exception = " + e.getMessage()); &#125; &#125; &#125;); btn3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try&#123; startRecord(); &#125;catch (Exception e)&#123; Log.e("dml","exception = " + e.getMessage()); &#125; &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if(mRecorder!=null)&#123; mRecorder.stop(); &#125; &#125; private void call()&#123; Intent intent = new Intent(); intent.setData(Uri.parse("tel://1212121212")); intent.setAction(Intent.ACTION_CALL); startActivity(intent); &#125; private void openCamera()&#123; camera = Camera.open(0); &#125; private void startRecord()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int bufferSize = AudioRecord.getMinBufferSize(8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT); mRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, 8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSize * 2); mRecorder.startRecording(); byte[] tempBuffer = new byte[bufferSize]; while(true)&#123; int recordCountSize = mRecorder.read(tempBuffer, 0, bufferSize); &#125; &#125; &#125;).start(); &#125;&#125; 拍照这次拍照没有闪退了，并且捕获到了异常,那直接在catch里面弹出Dialog就行了 E/dml: exception = Fail to connect to camera service 拨号但是拨号失败却没有任何异常，如何处理呢？我们可以在设置一个布尔值标志位(isNewCal)，监听到拨打电话的状态设为true，在拨出电话延迟500ms检测这个标志位，如果还是false说明拨打失败，然后排除移动网络异常，其他情况全部算作没有权限： 123456789101112TelephonyManager tm = (TelephonyManager)getSystemService(Service.TELEPHONY_SERVICE); tm.listen(new PhoneStateListener()&#123; @Override public void onCallStateChanged(int state, String incomingNumber) &#123; // TODO Auto-generated method stub super.onCallStateChanged(state, incomingNumber); if(state==TelephonyManager.CALL_STATE_OFFHOOK)&#123; isNewCall = true; &#125; &#125; &#125;, PhoneStateListener.LISTEN_CALL_STATE); 第二种方法处理拨号权限问题，就是换一种Intent，不要直接拨号而是跳到系统拨号界面，让用户自己点击拨号。123456private void jumpToDial()&#123; Intent intent = new Intent(Intent.ACTION_DIAL,Uri.parse("tel:1234567")); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125; 录音录音代码加了try catch，但是关闭权限没有捕获任何异常，但是可以看出录出来的数据缓冲区全部为0: 我们打开权限再看下： 因此我们可以取录音缓冲区的部分数据，如果全部为零，那么当作没权限立即通知录音并给出Dialog提示，这里我取缓冲区的前20个byte：12345678910111213141516171819202122232425262728293031 private void startRecord()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int bufferSize = AudioRecord.getMinBufferSize(8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT); mRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, 8000, AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSize * 2); mRecorder.startRecording(); byte[] tempBuffer = new byte[bufferSize]; byte[] checkBuffer = null; int valuePlus = 0; while(true)&#123; int recordCountSize = mRecorder.read(tempBuffer, 0, bufferSize); if(checkBuffer==null)&#123; checkBuffer = new byte[20]; System.arraycopy(tempBuffer,0,checkBuffer,0,20); for(int value:checkBuffer)&#123; valuePlus+=value; Log.d("dml","value = " + value); &#125; if(valuePlus==0)&#123; if(mRecorder!=null)&#123; mRecorder.stop(); Log.d("dml","stop record!"); &#125; break; &#125; &#125; &#125; &#125; &#125;).start();&#125; 总结try catch ＋ 数据异常判断的思路，上面我主要针对华为手机做了部分权限的适配，不过在公司测试来看也兼容魅族三星，如果除了大部分主流机型还有个别不能兼容怎么办？我的建议是让这些调皮的用户自己玩去吧。]]></content>
    </entry>

    
  
  
</search>
